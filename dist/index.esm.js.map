{
  "version": 3,
  "sources": ["../src/stateful-tab-frame-tracker.ts", "../src/tab-frame-tracker.ts", "../src/content-scripts/frame-monitor.ts"],
  "sourcesContent": ["import browser from \"webextension-polyfill\";\nimport { PersistentTabFrameTracker } from \"./persistent-tab-frame-tracker\";\nimport { CoreFrameInfo, TabFrameTracker } from \"./tab-frame-tracker\";\nimport {\n  diagnosticScript,\n  frameMonitorContentScript,\n} from \"./content-scripts/frame-monitor\";\n\n// Generic state management types\ntype TabState<T> = {\n  tabData: T;\n  frameStates: Map<number, any>;\n};\n\n// Enhanced query types\ntype TabWithFrameStates<T, F> = {\n  tabState: T;\n  frames: Map<\n    number,\n    {\n      frameInfo: CoreFrameInfo;\n      state?: F;\n    }\n  >;\n};\n\ntype FramePollingOptions = {\n  enabled: boolean;\n  interval?: number; // milliseconds\n  includeChildFrames?: boolean;\n};\n\nclass StatefulTabFrameTracker<\n  TabStateType extends object = any,\n  FrameStateType extends object = any\n> extends TabFrameTracker {\n  private tabStates: Map<number, TabState<TabStateType>> = new Map();\n  private frameSignatureMap: Map<number, Map<string, number>> = new Map();\n  private useInjection: boolean = false;\n  private pollingInterval?: number;\n  private framePollingOptions: FramePollingOptions;\n  private hasScriptingPermission: boolean = false;\n  private defaultTabState?: TabStateType;\n  private defaultFrameState?: FrameStateType;\n\n  constructor(\n    options: {\n      persistenceInterval?: number;\n      useInjection?: boolean;\n      framePolling?: FramePollingOptions;\n      defaultTabState?: TabStateType;\n      defaultFrameState?: FrameStateType;\n    } = {}\n  ) {\n    super();\n\n    this.useInjection = options.useInjection ?? false;\n\n    this.framePollingOptions = {\n      enabled: false,\n      interval: 5000,\n      includeChildFrames: true,\n      ...options.framePolling,\n    };\n\n    this.defaultTabState = options.defaultTabState;\n    this.defaultFrameState = options.defaultFrameState;\n\n    this.initialize();\n  }\n\n  private async initialize() {\n    // Check if we have scripting permission\n    const permissions = await browser.permissions.getAll();\n    this.hasScriptingPermission =\n      permissions.permissions?.includes(\"scripting\") || false;\n\n    console.log(\n      \"Initializing StatefulTabFrameTracker\",\n      {\n        hasScriptingPermission: this.hasScriptingPermission,\n        useInjection: this.useInjection,\n      },\n      this.framePollingOptions\n    );\n    if (this.hasScriptingPermission && this.useInjection) {\n      await this.initializeContentScriptSupport();\n    } else if (this.framePollingOptions.enabled) {\n      await this.initializeFramePolling();\n    }\n\n    if (this.defaultTabState) {\n      const existingTabs = await browser.tabs.query({});\n      for (const tab of existingTabs) {\n        if (tab.id && !this.tabStates.has(tab.id)) {\n          this.tabStates.set(tab.id, {\n            tabData: { ...this.defaultTabState },\n            frameStates: new Map(),\n          });\n        }\n      }\n    }\n  }\n\n  private async initializeFramePolling() {\n    if (!this.framePollingOptions.enabled) return;\n\n    const pollFrames = async () => {\n      const tabs = await browser.tabs.query({});\n\n      for (const tab of tabs) {\n        if (!tab.id) continue;\n\n        try {\n          const frames = await browser.webNavigation.getAllFrames({\n            tabId: tab.id,\n          });\n          if (!frames) continue;\n\n          const tabInfo = this.frameMap.get(tab.id);\n          if (!tabInfo) continue;\n\n          const currentFrameIds = new Set<number>();\n\n          for (const frame of frames) {\n            currentFrameIds.add(frame.frameId);\n\n            const existingFrame = tabInfo.frames.get(frame.frameId);\n            const frameUrl = frame.url;\n\n            if (!existingFrame) {\n              tabInfo.frames.set(frame.frameId, {\n                visible: true,\n                url: frameUrl,\n                parentFrameId:\n                  frame.parentFrameId >= 0 ? frame.parentFrameId : undefined,\n              });\n\n              if (this.defaultFrameState) {\n                const tabState = this.tabStates.get(tab.id);\n                if (tabState && !tabState.frameStates.has(frame.frameId)) {\n                  tabState.frameStates.set(frame.frameId, {\n                    ...this.defaultFrameState,\n                  });\n                }\n              }\n\n              this.notifyListeners({\n                type: \"added\",\n                tabId: tab.id,\n                frameId: frame.frameId,\n                currentState: {\n                  visible: true,\n                  url: frameUrl,\n                },\n              });\n            } else if (existingFrame.url !== frameUrl) {\n              // Frame URL changed\n\n              const previousUrl = existingFrame.url;\n              existingFrame.url = frameUrl;\n\n              this.notifyListeners({\n                type: \"modified\",\n                tabId: tab.id,\n                frameId: frame.frameId,\n                previousState: { url: previousUrl },\n                currentState: { url: frameUrl },\n              });\n            }\n          }\n\n          for (const [frameId, frameInfo] of tabInfo.frames) {\n            if (!currentFrameIds.has(frameId) && frameId !== 0) {\n              // Dont remove main frame\n              tabInfo.frames.delete(frameId);\n\n              const tabState = this.tabStates.get(tab.id);\n              if (tabState) {\n                tabState.frameStates.delete(frameId);\n              }\n\n              this.notifyListeners({\n                type: \"removed\",\n                tabId: tab.id,\n                frameId,\n                previousState: {\n                  url: frameInfo.url,\n                  visible: frameInfo.visible,\n                },\n              });\n            }\n          }\n        } catch (error) {\n          console.error(`Error polling frames for tab ${tab.id}:`, error);\n        }\n      }\n    };\n\n    await pollFrames();\n\n    this.pollingInterval = window.setInterval(\n      pollFrames,\n      this.framePollingOptions.interval\n    );\n  }\n\n  private async initializeContentScriptSupport() {\n    console.log(\"[ARGOS:BG] initializeContentScriptSupport()\");\n    // Listen for frame visibility changes from content scripts\n    browser.runtime.onMessage.addListener(\n      (message: any, sender: browser.Runtime.MessageSender) => {\n        if (message.type === \"frameVisibilityChange\") {\n          console.log(\n            \"[SHR:BG] StatefulTabFrameTracker, frameVisibilityChange: \",\n            message\n          );\n          const tabId = sender.tab?.id;\n          if (!tabId) return;\n\n          const frameSignature = message.frameId;\n\n          const tabInfo = this.frameMap.get(tabId!);\n          if (!tabInfo) return;\n\n          const frameEntry = Array.from(tabInfo.frames.entries()).find(\n            ([_, frameInfo]) => frameInfo.url === frameSignature\n          );\n\n          if (frameEntry) {\n            const [frameId, frameInfo] = frameEntry;\n\n            frameInfo.visible = message.visible;\n\n            // this.setFrameVisibility(tabId!, frameId, message.visible);\n            this.handleFrameVisibilityChange({ ...message, frameId });\n          }\n        }\n        return true;\n      }\n    );\n\n    this.subscribe(async (event) => {\n      if (event.type === \"modified\" && event.frameId === 0) {\n        // this.handleFrameVisibilityChange(event);\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n        try {\n          const tab = await browser.tabs.get(event.tabId);\n          await this.injectContentScript(tab);\n        } catch (err) {\n          console.warn(\n            `[ARGOS:BG] Failed to inject frame monitor into refreshed tab ${event.tabId}:`,\n            err\n          );\n        }\n      }\n    });\n\n    // Inject content script into existing tabs\n    const existingTabs = await browser.tabs.query({});\n    for (const tab of existingTabs) {\n      if (tab.id) {\n        await this.injectContentScript(tab);\n      }\n    }\n  }\n\n  private async injectContentScript(tab: browser.Tabs.Tab) {\n    if (!this.useInjection || !tab.id) return;\n\n    try {\n      const frameMonitorResult = await browser.scripting.executeScript({\n        target: { tabId: tab.id! },\n        func: frameMonitorContentScript,\n      });\n\n      const frameResult = frameMonitorResult[0]?.result;\n\n      if (frameResult?.success && frameResult.frames) {\n        console.log(\n          `[ARGOS:BG] Got initial frame visibility for tab ${tab.id}`,\n          frameResult.frames\n        );\n        const tabInfo = this.frameMap.get(tab.id!);\n        console.log(`[ARGOS:BG] Got tabInfo for comparison `, tabInfo);\n        if (!tabInfo) return;\n\n        frameResult.frames.forEach((frame: any) => {\n          const frameEntry = Array.from(tabInfo.frames.entries()).find(\n            ([_, frameInfo]) => frameInfo.url === frame.frameId\n          );\n\n          console.log(`[ARGOS:BG] Found frameEntry for comparison`, frameEntry);\n\n          if (frameEntry) {\n            console.log(`[ARGOS:BG] Found matching frame entry`, frameEntry);\n            const [frameId, frameInfo] = frameEntry;\n            frameInfo.visible = frame.visible;\n\n            this.handleFrameVisibilityChange({\n              frameId,\n              tabId: tab.id!,\n              visible: frame.visible,\n            });\n          }\n        });\n      }\n    } catch (error) {\n      console.warn(\n        `[ARGOS:BG] Failed to inject content script into tab ${tab.id}: ${tab.url}:`,\n        error\n      );\n      // If content script injection fails, fall back to polling for this tab\n      if (this.framePollingOptions.enabled) {\n        console.log(\n          `[ARGOS:BG] Script execution not enabled, falling back to polling for tab ${tab.id}`\n        );\n        this.pollFramesForTab(tab.id!);\n      }\n    }\n  }\n\n  private async pollFramesForTab(tabId: number) {\n    try {\n      const frames = await browser.webNavigation.getAllFrames({ tabId });\n      if (!frames) return;\n\n      const tabInfo = this.frameMap.get(tabId);\n      if (!tabInfo) return;\n\n      // Update frame information...\n      // (Similar logic to initializeFramePolling but for a single tab)\n    } catch (error) {\n      console.warn(`Failed to poll frames for tab ${tabId}:`, error);\n    }\n  }\n\n  private handleFrameVisibilityChange(message: any) {\n    const { frameId, tabId, visible } = message;\n    const frameInfo = this.getFrameInfo(tabId, frameId);\n\n    if (frameInfo) {\n      frameInfo.visible = visible;\n      this.notifyListeners({\n        type: \"visibility_changed\",\n        tabId,\n        frameId,\n        previousState: { visible: !visible },\n        currentState: { visible },\n      });\n    }\n  }\n\n  public setFrameVisibility(tabId: number, frameId: number, visible: boolean) {\n    const frameInfo = this.getFrameInfo(tabId, frameId);\n\n    if (frameInfo) {\n      frameInfo.visible = visible;\n      this.notifyListeners({\n        type: \"modified\",\n        tabId,\n        frameId,\n        previousState: { visible: !visible },\n        currentState: { visible },\n      });\n    }\n  }\n\n  // State management methods\n  public setTabState(\n    tabId: number,\n    state: TabStateType | Partial<TabStateType>\n  ): void {\n    const existing = this.tabStates.get(tabId);\n\n    if (!existing) {\n      if (this.isFullState<TabStateType>(state)) {\n        this.tabStates.set(tabId, {\n          tabData: state,\n          frameStates: new Map(),\n        });\n      } else if (this.defaultTabState) {\n        this.tabStates.set(tabId, {\n          tabData: { ...this.defaultTabState, ...state },\n          frameStates: new Map(),\n        });\n      } else {\n        throw new Error(\"Initial state must be a full state\");\n      }\n    } else {\n      this.tabStates.set(tabId, {\n        tabData: { ...existing.tabData, ...state },\n        frameStates: existing.frameStates,\n      });\n    }\n  }\n\n  public setFrameState(\n    tabId: number,\n    frameId: number,\n    state: FrameStateType | Partial<FrameStateType>\n  ): void {\n    let tabState = this.tabStates.get(tabId);\n\n    if (!tabState && this.defaultFrameState) {\n      tabState = {\n        tabData: { ...this.defaultTabState } as TabStateType,\n        frameStates: new Map(),\n      };\n      this.tabStates.set(tabId, tabState);\n    }\n\n    if (!tabState) return;\n\n    const existingFrameState = tabState.frameStates.get(frameId);\n\n    if (!existingFrameState) {\n      if (this.isFullState<FrameStateType>(state)) {\n        tabState.frameStates.set(frameId, state);\n      } else if (this.defaultFrameState) {\n        tabState.frameStates.set(frameId, {\n          ...this.defaultFrameState,\n          ...state,\n        });\n      } else {\n        throw new Error(\"Initial frame state must be a full state\");\n      }\n    } else {\n      tabState.frameStates.set(frameId, {\n        ...existingFrameState,\n        ...state,\n      });\n    }\n  }\n\n  private isFullState<T extends object>(state: T | Partial<T>): state is T {\n    const requiredKeys = Object.keys(this.getTypeTemplate<T>());\n    const stateKeys = Object.keys(state);\n\n    return requiredKeys.every((key) => stateKeys.includes(key));\n  }\n\n  private getTypeTemplate<T>(): Required<T> {\n    return {} as Required<T>;\n  }\n\n  public getTabState(tabId: number): TabStateType | undefined {\n    return this.tabStates.get(tabId)?.tabData ?? this.defaultTabState;\n  }\n\n  public getFrameState(\n    tabId: number,\n    frameId: number\n  ): FrameStateType | undefined {\n    const tabState = this.tabStates.get(tabId);\n    return tabState?.frameStates.get(frameId) ?? this.defaultFrameState;\n  }\n\n  // Query methods for tab states\n  public getAllTabsWithState(): Map<\n    number,\n    TabWithFrameStates<TabStateType, FrameStateType>\n  > {\n    const result = new Map<\n      number,\n      TabWithFrameStates<TabStateType, FrameStateType>\n    >();\n\n    for (const [tabId, tabState] of this.tabStates) {\n      const tabInfo = this.frameMap.get(tabId);\n      if (!tabInfo) continue;\n\n      result.set(tabId, {\n        tabState: tabState.tabData,\n        frames: new Map(\n          Array.from(tabInfo.frames.entries()).map(([frameId, frameInfo]) => [\n            frameId,\n            {\n              frameInfo,\n              state: tabState.frameStates.get(frameId),\n            },\n          ])\n        ),\n      });\n    }\n\n    return result;\n  }\n\n  public queryTabs(\n    predicate: (state: TabStateType) => boolean\n  ): Map<number, TabWithFrameStates<TabStateType, FrameStateType>> {\n    const result = new Map<\n      number,\n      TabWithFrameStates<TabStateType, FrameStateType>\n    >();\n\n    for (const [tabId, tabState] of this.tabStates) {\n      if (predicate(tabState.tabData)) {\n        const tabInfo = this.frameMap.get(tabId);\n        if (!tabInfo) continue;\n\n        result.set(tabId, {\n          tabState: tabState.tabData,\n          frames: new Map(\n            Array.from(tabInfo.frames.entries()).map(([frameId, frameInfo]) => [\n              frameId,\n              { frameInfo, state: tabState.frameStates.get(frameId) },\n            ])\n          ),\n        });\n      }\n    }\n\n    return result;\n  }\n\n  // Override cleanup to handle state\n  public dispose(): void {\n    if (this.pollingInterval) {\n      clearInterval(this.pollingInterval);\n    }\n    this.tabStates.clear();\n  }\n}\n\nexport { StatefulTabFrameTracker };\n", "import browser from \"webextension-polyfill\";\n\nexport type CoreFrameInfo = {\n  visible: boolean;\n  url: string; // Maybe add this if we can get it from events\n  parentFrameId?: number; // Maybe add this for hierarchy tracking\n};\n\ntype CoreTabInfo = {\n  url: string;\n  frames: Map<number, CoreFrameInfo>;\n};\n\ntype FrameMap = Map<number, CoreTabInfo>;\n\ntype ChangeType = \"added\" | \"removed\" | \"modified\" | \"visibility_changed\";\n\ntype ChangeEvent = {\n  type: ChangeType;\n  tabId: number;\n  frameId?: number;\n  previousState?: {\n    url?: string;\n    visible?: boolean;\n  };\n  currentState?: {\n    url?: string;\n    visible?: boolean;\n  };\n};\n\ntype ChangeListener = (event: ChangeEvent) => void;\n\nexport class TabFrameTracker {\n  public frameMap: FrameMap = new Map();\n  private listeners: Set<ChangeListener> = new Set();\n\n  constructor() {\n    this.initializeListeners();\n  }\n\n  public notifyListeners(event: ChangeEvent) {\n    this.listeners.forEach((listener) => listener(event));\n  }\n\n  public subscribe(listener: ChangeListener): () => void {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener); // Returns unsubscribe function\n  }\n\n  private async initializeListeners() {\n    // Listen for tab creation\n    browser.tabs.onCreated.addListener((tab: browser.Tabs.Tab) => {\n      if (tab.id) {\n        this.frameMap.set(tab.id, {\n          url: tab.url || \"\",\n          frames: new Map([[0, { visible: true, url: tab.url || \"\" }]]),\n        });\n\n        this.notifyListeners({\n          type: \"added\",\n          tabId: tab.id,\n          frameId: 0,\n          currentState: {\n            url: tab.url || \"\",\n            visible: true,\n          },\n        });\n      }\n    });\n\n    // Listen for tab updates (URL changes)\n    browser.tabs.onUpdated.addListener(\n      (\n        tabId: number,\n        changeInfo: browser.Tabs.OnUpdatedChangeInfoType,\n        tab: browser.Tabs.Tab\n      ) => {\n        const tabInfo = this.frameMap.get(tabId);\n\n        if (!tabInfo) return;\n\n        if (changeInfo.url || changeInfo.status === \"loading\") {\n          const previousUrl = tabInfo.url;\n          const newUrl = changeInfo.url || tab.url || previousUrl;\n          tabInfo.url = newUrl;\n\n          // Clear all frames except the main frame (0) on navigation\n          const mainFrame = tabInfo.frames.get(0);\n          tabInfo.frames.clear();\n          if (mainFrame) {\n            tabInfo.frames.set(0, { ...mainFrame, url: newUrl });\n          }\n\n          this.notifyListeners({\n            type: \"modified\",\n            tabId,\n            frameId: 0,\n            previousState: { url: previousUrl },\n            currentState: { url: newUrl, visible: true },\n          });\n        }\n      }\n    );\n\n    // Listen for tab removal\n    browser.tabs.onRemoved.addListener((tabId: number) => {\n      const tabInfo = this.frameMap.get(tabId);\n      if (tabInfo) {\n        this.frameMap.delete(tabId);\n\n        this.notifyListeners({\n          type: \"removed\",\n          tabId,\n          previousState: {\n            url: tabInfo.url,\n          },\n        });\n      }\n    });\n\n    // Listen for frame creation\n    browser.webNavigation.onCreatedNavigationTarget.addListener(\n      (details: browser.WebNavigation.OnCreatedNavigationTargetDetailsType) => {\n        const tabInfo = this.frameMap.get(details.tabId);\n        if (tabInfo && details.sourceFrameId) {\n          tabInfo.frames.set(details.sourceFrameId, {\n            visible: true,\n            url: details.url,\n          });\n\n          this.notifyListeners({\n            type: \"added\",\n            tabId: details.tabId,\n            frameId: details.sourceFrameId,\n            currentState: {\n              visible: true,\n            },\n          });\n        }\n      }\n    );\n\n    // Listen for frame navigation\n    browser.webNavigation.onCommitted.addListener(\n      (details: browser.WebNavigation.OnCommittedDetailsType) => {\n        const tabInfo = this.frameMap.get(details.tabId);\n        if (tabInfo && details.frameId) {\n          const frameExists = tabInfo.frames.has(details.frameId);\n          tabInfo.frames.set(details.frameId, {\n            visible: true,\n            url: details.url,\n          });\n\n          this.notifyListeners({\n            type: frameExists ? \"modified\" : \"added\",\n            tabId: details.tabId,\n            frameId: details.frameId,\n            currentState: {\n              visible: true,\n            },\n          });\n        }\n      }\n    );\n\n    // Listen for frame removal\n    browser.webNavigation.onBeforeNavigate.addListener(\n      (details: browser.WebNavigation.OnBeforeNavigateDetailsType) => {\n        const tabInfo = this.frameMap.get(details.tabId);\n        if (tabInfo && details.frameId) {\n          if (details.frameId !== 0) {\n            const frameInfo = tabInfo.frames.get(details.frameId);\n            tabInfo.frames.delete(details.frameId);\n\n            if (frameInfo) {\n              this.notifyListeners({\n                type: \"removed\",\n                tabId: details.tabId,\n                frameId: details.frameId,\n                previousState: {\n                  visible: frameInfo.visible,\n                },\n              });\n            }\n          }\n        }\n      }\n    );\n\n    // Initialize existing tabs\n    const existingTabs = await browser.tabs.query({});\n    for (const tab of existingTabs) {\n      if (tab.id) {\n        this.frameMap.set(tab.id, {\n          url: tab.url || \"\",\n          frames: new Map([[0, { visible: true, url: tab.url || \"\" }]]),\n        });\n\n        this.notifyListeners({\n          type: \"added\",\n          tabId: tab.id,\n          frameId: 0,\n          currentState: {\n            url: tab.url || \"\",\n            visible: true,\n          },\n        });\n      }\n    }\n\n    // Handle window removal\n    browser.windows.onRemoved.addListener(async (windowId: any) => {\n      const tabs = await browser.tabs.query({ windowId });\n      for (const tab of tabs) {\n        if (tab.id) {\n          const tabInfo = this.frameMap.get(tab.id);\n          this.frameMap.delete(tab.id);\n\n          if (tabInfo) {\n            this.notifyListeners({\n              type: \"removed\",\n              tabId: tab.id,\n              previousState: {\n                url: tabInfo.url,\n              },\n            });\n          }\n        }\n      }\n    });\n  }\n\n  // Helper methods\n  public getTabInfo(tabId: number): CoreTabInfo | undefined {\n    return this.frameMap.get(tabId);\n  }\n\n  public getFrameInfo(\n    tabId: number,\n    frameId: number\n  ): CoreFrameInfo | undefined {\n    return this.frameMap.get(tabId)?.frames.get(frameId);\n  }\n\n  public getAllTabs(): FrameMap {\n    return this.frameMap;\n  }\n}\n", "//import browser from \"webextension-polyfill\";\n\n// import browser from \"webextension-polyfill\";\n// declare const browser: typeof import(\"webextension-polyfill\");\n// frame-monitor.ts - Content script for frame monitoring\n\nconsole.log(\"[ARGOS:CS] frame monitor mounted\");\nexport const frameMonitorContentScript = function () {\n  console.log(\"[ARGOS:CS] frame monitor running\");\n  const VISIBILITY_CHECK_INTERVAL = 10000; // 1 second\n\n  function isStyleHidden(element: HTMLElement): boolean {\n    const style = window.getComputedStyle(element);\n    return (\n      style.display === \"none\" ||\n      style.visibility === \"hidden\" ||\n      style.opacity === \"0\" ||\n      style.width === \"0px\" ||\n      style.height === \"0px\"\n    );\n  }\n\n  function isOffscreen(rect: DOMRect): boolean {\n    // Check if element is completely off-screen\n    return (\n      rect.right <= 0 ||\n      rect.bottom <= 0 ||\n      rect.left >= window.innerWidth ||\n      rect.top >= window.innerHeight\n    );\n  }\n\n  function hasZeroDimension(element: HTMLElement): boolean {\n    return element.offsetWidth <= 0 || element.offsetHeight <= 0;\n  }\n\n  function isParentHidden(element: HTMLElement): boolean {\n    let parent = element.parentElement;\n    while (parent) {\n      if (isStyleHidden(parent)) {\n        return true;\n      }\n      parent = parent.parentElement;\n    }\n    return false;\n  }\n\n  function hasVisibleArea(element: HTMLElement): boolean {\n    const rects = element.getClientRects();\n    if (!rects || rects.length === 0) {\n      return false;\n    }\n\n    // Check if any rect has a meaningful area\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      if (rect.width > 0 && rect.height > 0 && !isOffscreen(rect)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function checkFrameVisibility(frame: HTMLIFrameElement): boolean {\n    try {\n      // 1. Basic style checks\n      if (isStyleHidden(frame)) {\n        return false;\n      }\n\n      // 2. Check parent elements\n      if (isParentHidden(frame)) {\n        return false;\n      }\n\n      // 3. Check dimensions\n      if (hasZeroDimension(frame)) {\n        return false;\n      }\n\n      // 4. Check if frame has any visible rectangles\n      if (!hasVisibleArea(frame)) {\n        return false;\n      }\n\n      // 5. Try to check frame content if same-origin\n      try {\n        const frameDoc = frame.contentDocument;\n        if (frameDoc && frameDoc.body) {\n          if (hasZeroDimension(frameDoc.body)) {\n            return false;\n          }\n        }\n      } catch (e) {\n        // Cross-origin access will fail - that's okay\n        // We'll rely on the other checks in this case\n      }\n\n      // Additional checks for specific scenarios\n      const rect = frame.getBoundingClientRect();\n\n      // Check if frame is too small to be meaningful\n      if (rect.width < 2 && rect.height < 2) {\n        return false;\n      }\n\n      // Check if frame is covered by other elements\n      const centerX = rect.left + rect.width / 2;\n      const centerY = rect.top + rect.height / 2;\n      const elementAtPoint = document.elementFromPoint(centerX, centerY);\n      if (\n        elementAtPoint &&\n        !frame.contains(elementAtPoint) &&\n        !elementAtPoint.contains(frame)\n      ) {\n        // Something else is covering the center of the frame\n        // But only consider it hidden if a significant portion is covered\n        const coverageThreshold = 0.9; // 90% coverage to consider hidden\n        const elementsAtCorners = [\n          document.elementFromPoint(rect.left + 2, rect.top + 2),\n          document.elementFromPoint(rect.right - 2, rect.top + 2),\n          document.elementFromPoint(rect.left + 2, rect.bottom - 2),\n          document.elementFromPoint(rect.right - 2, rect.bottom - 2),\n        ];\n\n        const coveredCorners = elementsAtCorners.filter(\n          (el) => el && !frame.contains(el) && !el.contains(frame)\n        ).length;\n\n        if (coveredCorners >= 3) {\n          // If 3 or more corners are covered\n          return false;\n        }\n      }\n\n      console.log(\"[ARGOS:CS] checkFrameVisibility: true\");\n      return true;\n    } catch (error) {\n      console.warn(\"Error checking frame visibility:\", error);\n      // In case of error, default to considering it visible\n      return true;\n    }\n  }\n\n  function setupFrameMonitoring() {\n    // Track all iframes\n    const frames = new Map<HTMLIFrameElement, boolean>();\n\n    console.log(\"[ARGOS:CS] setupFrameMonitoring\");\n    // Initial frame discovery\n    document.querySelectorAll(\"iframe\").forEach((frame) => {\n      console.log(\"[ARGOS:CS] setupFrameMonitoring: initial frame discovery\");\n      frames.set(\n        frame as HTMLIFrameElement,\n        checkFrameVisibility(frame as HTMLIFrameElement)\n      );\n    });\n\n    // Set up mutation observer for frame changes\n    const observer = new MutationObserver((mutations) => {\n      mutations.forEach((mutation) => {\n        mutation.addedNodes.forEach((node) => {\n          if (node instanceof HTMLIFrameElement) {\n            console.log(\n              \"[ARGOS:CS] mutation : added node, checking frame visibility\"\n            );\n            frames.set(node, checkFrameVisibility(node));\n          }\n        });\n\n        mutation.removedNodes.forEach((node) => {\n          if (node instanceof HTMLIFrameElement) {\n            console.log(\"[ARGOS:CS] mutation : removed node\");\n            frames.delete(node);\n          }\n        });\n      });\n    });\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n    });\n\n    // Monitor visibility changes\n    const intersectionObserver = new IntersectionObserver(\n      (entries) => {\n        entries.forEach((entry) => {\n          if (entry.target instanceof HTMLIFrameElement) {\n            const frame = entry.target;\n            console.log(\n              \"[ARGOS:CS] intersection observer : checking frame visibility\"\n            );\n            const isVisible = checkFrameVisibility(frame);\n\n            if (frames.get(frame) !== isVisible) {\n              frames.set(frame, isVisible);\n              chrome.runtime.sendMessage({\n                type: \"frameVisibilityChange\",\n                frameId: frame.src,\n                visible: isVisible,\n              });\n            }\n          }\n        });\n      },\n      {\n        threshold: [0, 0.1, 0.5, 1.0], // Check at different visibility thresholds\n      }\n    );\n\n    // Periodic visibility checking for other cases\n    setInterval(() => {\n      frames.forEach((oldVisible, frame) => {\n        const newVisible = checkFrameVisibility(frame);\n        console.log(`[ARGOS:CS:${frame.id}] periodic visibility checking`, {\n          src: frame.src,\n          visible: newVisible,\n        });\n        if (oldVisible !== newVisible) {\n          console.log(`[ARGOS:CS:${frame.id}] found visibility change!`);\n          frames.set(frame, newVisible);\n          chrome.runtime.sendMessage({\n            type: \"frameVisibilityChange\",\n            frameId: frame.src,\n            visible: newVisible,\n          });\n        }\n      });\n    }, VISIBILITY_CHECK_INTERVAL);\n\n    return {\n      success: true,\n      frames: Array.from(frames, ([key, value]) => ({\n        frameId: key.src,\n        visible: value,\n      })),\n    };\n  }\n\n  return setupFrameMonitoring();\n};\n\nexport const diagnosticScript = function () {\n  console.log(\"[ARGOS:CS] Diagnostic running\");\n  console.log(\"[ARGOS:CS] Window location:\", window.location.href);\n  console.log(\"[ARGOS:CS] Document readyState:\", document.readyState);\n\n  // Test if browser API is available\n  if (typeof chrome !== \"undefined\") {\n    console.log(\"[ARGOS:CS] browser API is available\");\n    chrome.runtime\n      .sendMessage({\n        type: \"diagnostic\",\n        message: \"Diagnostic script successfully ran\",\n      })\n      .catch((e) => console.log(\"[ARGOS:CS] Failed to send message:\", e));\n  } else {\n    console.log(\"[ARGOS:CS] browser API is NOT available!\");\n  }\n\n  return {\n    success: true,\n    iframes: document.getElementsByTagName(\"iframe\").length,\n  };\n};\n"],
  "mappings": "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",
  "names": ["browser", "browser"]
}
